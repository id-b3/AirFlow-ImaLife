import subprocess
import sys
from pathlib import Path
from .split.compute_boundbox_regions import comp_bound_box
from .split.split_segmentation_regions import split_seg_reg
from datetime import datetime
import logging

# Script constants
opfront_script = str((Path(__file__).parent / "scripts/opfront_phantom_single.sh").resolve())
measure_split = str((Path(__file__).parent / "scripts/measure_phantom_single.sh").resolve())

# TODO: File constants - incorrect, have to obtain from the running process... in case the volume name is different.
p_surf_0 = "./phantom_volume_surface0.nii.gz"
p_surf_1 = "./phantom_volume_surface1.nii.gz"


class PhantomTrainer:
    def __init__(self, p_vol: str, p_seg: str, out_dir: str, log_lev: int = logging.DEBUG):
        """
        Phantom Trainer class. Contains the information to repeatedly run the process_phantom method, which calculates
        an error meaasure for a given set of parameters.

        Parameters
        ----------
        p_vol: str
            Phantom volume file
        p_seg: str
            Phantom segmentation file
        out_dir: str
            Output Directory for this training run.
        """

        self.volume = Path(p_vol).resolve()
        self.segmentation = str(Path(p_seg).resolve())
        self.out_dir = Path(out_dir).resolve()
        self.out_dir.mkdir(parents=True)
        (self.out_dir / "logs").mkdir()
        (self.out_dir / "common_files").mkdir()

        self.log_dir = str(self.out_dir / "logs" / f"training_log_{datetime.now()}.log")
        self.bound_box = str(self.out_dir / "common_files" / "boundboxes_split_regions_phantom.npy")

        # Compute and output the boundinx boxes for splitting.
        comp_bound_box(self.segmentation, self.bound_box)

        logging.basicConfig(level=log_lev, filename=self.log_dir)
        logging.getLogger().addHandler(logging.StreamHandler(sys.stdout))

    # TODO: Create a function that runs one loop of phantom opfront and measuring. Returns an error measure.
    def process_phantom(self, run_number: int,
                        op_par: str = "-i 15 -o 15 -I 2 -O 2 -b 0.4 -k 0.5 -r 0.7 -c 17 -e 0.7 -K 0",
                        i_der: float = 0, o_der: float = 0, s_pen: float = 0) -> float:
        """
        A method that processes the phantom and calculates an error measure.

        Parameters
        ----------
        run_number: int
            The number of the current run.
        op_par: str
            Opfront Parameters
        i_der: float
            Inner derivative - test variable (range -1 to 1)
        o_der: float
            Outer derivative - test variable (range -1 to 1)
        s_pen: float
            Separation penalty - test variable (range 0 to 10)

        Returns
        -------
        The error measure for this set of opfront parameters.
        """

        err_m = 1  #: The error measure. Initialised to 1
        parameters = f"{op_par} -F {i_der} -G {o_der} -d {s_pen}"
        run_out_dir = str(self.out_dir / f"run_{run_number}_F{i_der}G{o_der}d{s_pen}")  #: Dir for current run output

        logging.info(
            f"Starting Phantom {str(self.volume)} Training Run No.{run_number} with parameters '{parameters}'\n"
            f"Outputdir {run_out_dir} \n"
            f"----------------------------------------------------------------\n")

        # 1. run opfront with parameters VOL SEG OUT_DIR OPFRONT_PARAMS
        logging.debug(f"Launching opfront for {str(self.volume)} number {run_number}...")
        subprocess.run([opfront_script, str(self.volume), self.segmentation, run_out_dir, parameters])

        # 2. split the airways
        logging.debug(f"Splitting results for opfront number {run_number}...")
        split_out_dir = split_seg_reg(run_out_dir, self.bound_box)
        logging.debug(f"Split phantom airways into {split_out_dir}...")

        # 3. measure the airways - iterate within the folders generated by split, output into same folder
        for split_path in Path(split_out_dir).iterdir():
            logging.debug(f"Measuring results for run {run_number} and {split_path.stem}...")
            inner_vol, outer_vol = self.get_split_vol(split_path)
            logging.debug(f"Split surface dirs are: \n"
                          f"{inner_vol}\n{outer_vol}")
            subprocess.run([measure_split, str(self.volume), inner_vol, outer_vol, str(split_path.resolve())])

        # TODO Merge all results into one CSV
        # 4. merge the airways
        logging.debug(f"Merging results for run {run_number}...")

        # 5. calculate the error measure
        logging.debug(f"Calculating error measure for run {run_number}...")
        # return the error measure
        logging.info(f"Error measure for {str(self.volume)} run No. {run_number} is: {err_m}")
        return err_m

    def get_split_vol(self, split_dir: Path) -> tuple:
        """
        Get the surface0 and surface1 paths from split code to feed into the measurement script.

        Parameters
        ----------
        split_dir: Path
            The directory path to the split phantom airway
        Returns
        -------
        Inner and outer surface paths as strings
        """
        # Create filepaths for the measure_phantom script to match the opfront_phantom script.
        root_out = split_dir / self.volume.stem.partition('.')[0]
        logging.debug(f"Getting surface filenames relative to split folder \n{root_out}")
        return str(Path(f"{root_out}_surface0.nii.gz").resolve()), str(Path(f"{root_out}_surface1.nii.gz").resolve())
